\doxysection{GIM\+\_\+\+BVH\+\_\+\+DATA\+\_\+\+ARRAY Class Reference}
\hypertarget{class_g_i_m___b_v_h___d_a_t_a___a_r_r_a_y}{}\label{class_g_i_m___b_v_h___d_a_t_a___a_r_r_a_y}\index{GIM\_BVH\_DATA\_ARRAY@{GIM\_BVH\_DATA\_ARRAY}}
Inheritance diagram for GIM\+\_\+\+BVH\+\_\+\+DATA\+\_\+\+ARRAY\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_g_i_m___b_v_h___d_a_t_a___a_r_r_a_y}
\end{center}
\end{figure}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{classbt_aligned_object_array}{bt\+Aligned\+Object\+Array$<$ GIM\+\_\+\+BVH\+\_\+\+DATA $>$}}}
\begin{DoxyCompactItemize}
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE \mbox{\hyperlink{classbt_aligned_object_array}{bt\+Aligned\+Object\+Array}}$<$ \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} $>$ \& {\bfseries operator=} (const \mbox{\hyperlink{classbt_aligned_object_array}{bt\+Aligned\+Object\+Array}}$<$ \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} $>$ \&other)
\item 
{\bfseries bt\+Aligned\+Object\+Array} (const \mbox{\hyperlink{classbt_aligned_object_array}{bt\+Aligned\+Object\+Array}} \&other\+Array)
\begin{DoxyCompactList}\small\item\em Generally it is best to avoid using the copy constructor of an \doxylink{classbt_aligned_object_array}{bt\+Aligned\+Object\+Array}, and use a (const) reference to the array instead. \end{DoxyCompactList}\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE int {\bfseries size} () const
\begin{DoxyCompactList}\small\item\em return the number of elements in the array \end{DoxyCompactList}\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE const \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \& {\bfseries at} (int n) const
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \& {\bfseries at} (int n)
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE const \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \& {\bfseries operator\mbox{[}$\,$\mbox{]}} (int n) const
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \& {\bfseries operator\mbox{[}$\,$\mbox{]}} (int n)
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE void {\bfseries clear} ()
\begin{DoxyCompactList}\small\item\em clear the array, deallocated memory. Generally it is better to use array.\+resize(0), to reduce performance overhead of run-\/time memory (de)allocations. \end{DoxyCompactList}\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE void {\bfseries pop\+\_\+back} ()
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE void \mbox{\hyperlink{classbt_aligned_object_array_a2cc58c74534181a7a10e5c6ab8b21227}{resize\+No\+Initialize}} (int newsize)
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE void {\bfseries resize} (int newsize, const \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \&fill\+Data=\mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}}())
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \& {\bfseries expand\+Non\+Initializing} ()
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \& {\bfseries expand} (const \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \&fill\+Value=\mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}}())
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE void {\bfseries push\+\_\+back} (const \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \&\+\_\+\+Val)
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE int {\bfseries capacity} () const
\begin{DoxyCompactList}\small\item\em return the pre-\/allocated (reserved) elements, this is at least as large as the total number of elements,see size() and reserve() \end{DoxyCompactList}\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE void {\bfseries reserve} (int \+\_\+\+Count)
\item 
void {\bfseries quick\+Sort\+Internal} (const L \&Compare\+Func, int lo, int hi)
\item 
void {\bfseries quick\+Sort} (const L \&Compare\+Func)
\item 
void {\bfseries down\+Heap} (\mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \texorpdfstring{$\ast$}{*}p\+Arr, int k, int n, const L \&Compare\+Func)
\begin{DoxyCompactList}\small\item\em heap sort from \href{http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Heap/}{\texttt{ http\+://www.\+csse.\+monash.\+edu.\+au/\texorpdfstring{$\sim$}{\string~}lloyd/tilde\+Alg\+DS/\+Sort/\+Heap/}} \end{DoxyCompactList}\item 
void {\bfseries swap} (int index0, int index1)
\item 
void {\bfseries heap\+Sort} (const L \&Compare\+Func)
\item 
int {\bfseries find\+Binary\+Search} (const \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \&key) const
\begin{DoxyCompactList}\small\item\em non-\/recursive binary search, assumes sorted array \end{DoxyCompactList}\item 
int {\bfseries find\+Linear\+Search} (const \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \&key) const
\item 
int {\bfseries find\+Linear\+Search2} (const \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \&key) const
\item 
void {\bfseries remove\+At\+Index} (int index)
\item 
void {\bfseries remove} (const \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \&key)
\item 
void {\bfseries initialize\+From\+Buffer} (void \texorpdfstring{$\ast$}{*}buffer, int \mbox{\hyperlink{classbt_aligned_object_array_a31de8d83d29c6edd1493fc583091194c}{size}}, int \mbox{\hyperlink{classbt_aligned_object_array_a1baf76f9f52df3c2d742194ba33e8788}{capacity}})
\item 
void {\bfseries copy\+From\+Array} (const \mbox{\hyperlink{classbt_aligned_object_array}{bt\+Aligned\+Object\+Array}} \&other\+Array)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions inherited from \mbox{\hyperlink{classbt_aligned_object_array}{bt\+Aligned\+Object\+Array$<$ GIM\+\_\+\+BVH\+\_\+\+DATA $>$}}}
\begin{DoxyCompactItemize}
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE int {\bfseries alloc\+Size} (int \mbox{\hyperlink{classbt_aligned_object_array_a31de8d83d29c6edd1493fc583091194c}{size}})
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE void {\bfseries copy} (int start, int end, \mbox{\hyperlink{struct_g_i_m___b_v_h___d_a_t_a}{GIM\+\_\+\+BVH\+\_\+\+DATA}} \texorpdfstring{$\ast$}{*}dest) const
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE void {\bfseries init} ()
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE void {\bfseries destroy} (int first, int last)
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE void \texorpdfstring{$\ast$}{*} {\bfseries allocate} (int \mbox{\hyperlink{classbt_aligned_object_array_a31de8d83d29c6edd1493fc583091194c}{size}})
\item 
SIMD\+\_\+\+FORCE\+\_\+\+INLINE void {\bfseries deallocate} ()
\end{DoxyCompactItemize}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/\+Usuario/\+Documents/pruebas-\/c/\+Practica Animaci√≥n/libraries/bullet-\/3.\+17/src/\+Bullet\+Collision/\+Gimpact/bt\+GImpact\+Bvh.\+h\end{DoxyCompactItemize}
